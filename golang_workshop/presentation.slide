Golang Workshop
27 February 2016

Baiju Muthukadan
Architect, ZeOmega
http://muthukadan.net
@baijum

* About Me

- Technical Architect at ZeOmega, Bangalore
- Python Developer for 12+ years
- FOSS Contributor (Zope, SMC, Koha, Salt etc.)
- Founded the Swathanthra Malayalam Computing (SMC) project in 2001 while studying at REC Calicut (NIT Kozhikode)
- Conducted many Python related talks and workshops in India
- In 2013, received the first Kenneth Gonsalves Award for my contributions to the Python community in India
- In 2014, started using Go for hobby projects

* Facts

- General Purpose Programming Language
- Free/Open Source
- Created at Google by Robert Griesemer, Rob Pike and Ken Thompson
- Development started in 2007 and publicly released in November 2009
- C like syntax (no semicolons)
- Object Oriented (Composition over inheritance - no classes!)
- Compiled (Statically linked)
- Garbage collected
- Statically typed
- Strongly typed
- built-in concurrency

* Facts ...

- Two main compilers: gc & gccgo
- 25 keywords (less than C,C++,Python etc.)
- Classification (Capitalized are exported)
- Fast build
- Unused imports and variables raise compile error
- Operating Syatems: Windows, GNU/Linux, Mac OS X, *BSD
- CPU Architectures: amd64, 386, arm
- Cross compilation
- Standard library
- No exceptions
- Pointers (No pointer arithmetic!)

* Hello, ലോകമേ!

.play code/hello.go

* Why Go ?

- Simplicity (Minimal design)
- Consistency (Orthogonal features)
- Readability
- Safety (Type safety, no buffer overflows, no pointer arithmetic)
- Built-in concurrency features
- Speed

* Installing Go Compiler

- Download Go compiler binary from [[https://golang.org/dl][https://golang.org/dl]]
- Extract it into your home directory (`$HOME/go`)
- Create directory named `mygo` in your home directory (`$HOME/mygo`)
- Add the following lines to your `$HOME/.bashrc`


    export GOROOT=$HOME/go
    export PATH=$PATH:$GOROOT/bin

    export GOPATH=$HOME/mygo
    export PATH=$PATH:$GOPATH/bin

* Building and Running

- You can run the program using "go run" command: go run hello.go
- You can also build (compile) and run the binary like this in GNU/Linux:

    go build hello.go
    ./hello

(The first command produce a binary and second comand executs the binary)

- The "go build" command produce a binary file native to the operating system and the architecture of the CPU (i386, x86_64 etc.)



* Variables

- Type is explicitly specified but initialized with default zero values

    var age int
    var name, place string

- The zero value is 0 for numeric types, false for boolean type and empty string for strings.

- Type is explicitly specified and initialized with given values

    var age int = 10
    var name, place string = "Jack", "USA"


* Variables ...

- Type is inferred from the values that is given for initialization

    var x = 42             // int
    var s, b = "foo", true // string, bool

- Short variable declaration inside functions (Similar to above - type is inferred from the values that is given for initialization)

    x := 42             // int
    s, b := "foo", true // string, bool


* Constants

- Constants are declared like variables, but with the const keyword.
- Constants can be character, string, boolean, or numeric values.
- Constants cannot be declared using the := syntax.

    const Male = true
    const Pi = 3.14
    const Country = "India"

* Go Types (Primitive types)

int, uint, int8, uint8, ...
bool, string
float32, float64
complex64, complex128

* Go Types (Structs)

- A struct is a collection of fields.
- Struct fields are accessed using a dot.

.play code/struct1.go /START OMIT/,/END OMIT/

* Go Types (Slices and Arrays)


    []int, [3]string, []struct{ Name string }

- An array's length is part of its type, so arrays cannot be resized.
- A slice points to an array of values and also includes a length.
- []T is a slice with elements of type T
- len(s) returns the length of slice s
- Slices can contain any type, including other slices

* Go Types (Maps)

- A map maps keys to values
- Maps must be created with make before use
- the nil map is empty and cannot be assigned to

    map[string]int

* Go Types (Pointers)

    *int, *Person

* Type declarations

type [name] [specification]

Example 1: Celsius is a float64 type

    type Celsius float64

Example 2: Person is a struct type

    type Person struct {
        name string
        age  int
    }

* Function declarations

func [name] ([params]) [return value]
func [name] ([params]) ([return values])

A function to return sum of two int values:

    func sum(a int, b int) int {
        return a + b
    }

* Function declarations ...

A function with multiple returned values:

    func div(a, b int) (int, int)
        return a / b, a % b
    }

* Function declarations ...

Made clearer by naming the return values:

    func div(den, div int) (q, rem int)
        return a / b, a % b
    }

* If Conditions

- Syntax inspired by C
- No parenthesis (not even optional)
- Curly brace is mandatory

.play code/if1.go /START OMIT/,/END OMIT/

* If Conditions ...

- The if statement can start with a short statement to execute before the condition
- Variables declared by the statement are only in scope until the end of the if
- Variables declared inside an if short statement are also available inside any of the else blocks

.play code/if2.go /START OMIT/,/END OMIT/

* Command line arguments

- os.Args provides access to raw command-line arguments
- Go provides a "flag" package supporting basic command-line flag parsing

* Packages

- Package name must be declared in source files
- To create executable use name of package as _main_
- Programs start running in package main

    package main

* Packages ...

- Import give access to exported stuff from other packages
- Package name is the same as the last element of the import path
- Initialization logic for package goes into a function named _init_
- Use alias to avoid package name ambiguity with package imports

    import (
    	   "fmt"

           myfmt "github.com/baijum/fmt"
    )

* Packages ...

- Use blank identifier (`_`) as import alias to invoke _init_ function without using the package


    import (
           "database/sql"

           _ "github.com/lib/pq"
    )

* For Loop

- The only looping construct (no while loop)
- Syntax inspired by C
- No parenthesis (not even optional)
- Curly brace is mandatory

.play code/for1.go /START OMIT/,/END OMIT/

* For Loop ...

- Pre and post statements can be empty (and drop the semicolons!)

.play code/for2.go /START OMIT/,/END OMIT/

* For Loop ...

- An infinite loop can be created by removing the loop condition

.play code/for3.go /START OMIT/,/END OMIT/

* Switch statement

- The cases are evaluated top to bottom until a match is found
- There is no automatic fall through
- Cases can be presented in comma-separated lists
- break statements can be used to terminate a switch early

* Switch statement ...

	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}

* Switch statement ...

If the switch has no expression it switches on true (useful to write an if-else-if-else chain)

	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}

* Method declaration

func ([receiver]) [name] ([params]) ([return values])

* Method declaration ...

A method on a struct:

    func (p Person) Major() bool {
        return p.age >= 18
    }

* Method declaration ...

But also a method on a float64:

    func (c Celsius) Freezing() bool {
        return c <= 0
    }

* Method declaration ...

Constraint: Methods can be defined only on types declared in the same package.

    // This won't compile
    func (s string) Length() int { return len(s) }

* Errors

- Go programs express error state with _error_ values
- The error type is a built-in interface

    type error interface {
        Error() string
    }

* Errors ...

- Functions often return an error value, and calling code should
  handle errors by testing whether the error equals nil.

    i, err := strconv.Atoi("42")
    if err != nil {
        fmt.Printf("couldn't convert number: %v\n", err)
        return
    }
    fmt.Println("Converted integer:", i)

- A nil error denotes success; a non-nil error denotes failure.

* Pointers

Use `&` to obtain the address of a variable.

    a := "hello"
    p := &a

* Pointers ...

Use `*` to dereference the pointer.

    fmt.Print(*p + ", world")

* Pointers ...

No pointer arithmetic, no pointers to unsafe memory.

    a := "hello"
    p := &a
    p += 4  // no, you can't

* Pointers ...

- Control what you pass to functions.
- passing values, no side-effects:

    func double(x int) {
        x *= 2
    }

- passing pointers: side-effects possible:

    func double(x *int) {
        *x *= 2
    }

* Defer statement

- Ensure a cleanup function is called later
- To recover from runtime panic
- Executed in LIFO order

    func main() {
        defer fmt.Println("world")

        fmt.Println("hello")
    }

* Interfaces

Named collections of method signatures

    type Geometry interface {
        Area() float64
        Perimeter() float64
    }

* Go Tools

- build - compile packages and dependencies
- fmt - run gofmt on package sources
- get - download and install packages and dependencies
- install - compile and install packages and dependencies
- run - compile and run Go program
- test - test packages
- version - print Go version
- vet - run go tool vet on packages

* Concurrency

- Goroutines are lightweight threads managed by the Go runtime
- Calling a function with _go_ keyword starts the goroutine

    go Sum(x, y)

- Goroutines can communicate to each other via channels (typed conduit)

* Concurrency ...

- You can send and receive values with the channel operator: <-

    ch <- v    // Send v to channel ch.
    v := <-ch  // Receive from ch, and
               // assign value to v.

- The data flows in the direction of the arrow.
- Channels must be created before use:

    ch := make(chan int)

- Sends and receives block until the other side is ready

* Hello HTTP

.play code/hellohttp.go

* WaitGroup

- _sync.WaitGroup_ provides a goroutine synchronization mechanism in Golang
- A WaitGroup waits for a collection of goroutines to finish
- _sync.WaitGroup_ provides 3 methods: Add, Done and Wait.
- _Add_ method is used to identify how many goroutines need to be waited
- When a goroutine exits, it must call _Done_
- The main goroutine blocks on _Wait_

* Who uses Go?

- Google
- Dropbox
- BBC
- Dailymotion
- Docker
- Disqus
- SoundCloud
- UserVoice
- [[https://github.com/golang/go/wiki/GoUsers][https://github.com/golang/go/wiki/GoUsers]]
- [[https://github.com/golang/go/wiki/SuccessStories][https://github.com/golang/go/wiki/SuccessStories]]

* Go Resources

- Use the word "golang" to search about Go in Google, Bing etc.
- Twitter hashtag #golang #GopherCon #GopherConIndia
- Official website: http://golang.org
- Official blog: http://blog.golang.org
- https://gobyexample.com
- Forum/Mailing List: https://groups.google.com/forum/#!forum/golang-nuts
- Subreddit: http://www.reddit.com/r/golang
- #go-nuts in the irc.freenode.org network
- Slack: [[https://gophersinvite.herokuapp.com/][https://gophersinvite.herokuapp.com/]]
- More: http://dave.cheney.net/resources-for-new-go-programmers

* My Book: A Comprehensive Guide to Go Programming

Subscribe for sample chapters!

[[http://golang.muthukadan.net][http://golang.muthukadan.net]]
